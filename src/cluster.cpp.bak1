/**
 * Author      : Masrul Huda (mail2masrul@gmail.com)
 * Host        : iMacPro@Swalm
 * Created     : Tuesday Jul 05, 2022 10:01:02 CDT
 */

#include "gmx_traj.hpp"
#include <vector>
#include<map>
#include <cmath>
#include <iostream>
#include <limits>

class Graph {
public:
    std::map<int,std::vector<int>>adjList;
    std::map<int,bool> visited; 
    std::vector<int>nodes;
    std::vector<std::vector<int>>connected_components; 
    std::vector<int>subgraph; 
    Graph(std::vector<int>nodes):nodes(nodes){
        for (int a: nodes){
            std::vector<int> _temp{};
            adjList[a] = _temp;
            visited[a] = false; 
        }
    }

    void add_edges(int a, int b){
        adjList[a].push_back(b);
        adjList[b].push_back(a);
    }

    void find_connected_component(){
    /*
     Algo for connected component from following source
     https://cp-algorithms.com/graph/search-for-connected-components.html
     */
        // set visited false 
        for (auto node : nodes)
            visited[node] = false;

        for (auto node : nodes){
            if (!visited[node]){
                subgraph.clear();
                DFS(node);
                connected_components.push_back(subgraph);
            }
        }
    }

    void DFS(int node){
        visited[node]=true; 
        subgraph.push_back(node);

        for (auto neigh : adjList[node])
            if (!visited[neigh]) DFS(neigh);
    }
};


class Cluster {
public:
    std::string molecule_name;
    float rcut=0.35; // nm 
    int nClusters; 
    int max_cluster_size;
    std::vector<int> polymer_counts; // no of mono, di, trimer etc
    std::vector<std::vector<int>> clusters; 

    Cluster(std::string _molecule_name):molecule_name(_molecule_name){};
    /* ~Cluster(); */
    void set_rcut(float);
    void run(GMXTraj&);


private:
    std::vector<int> nodes;
    std::vector<std::vector<int>> edges; 
    void _create_edges(GMXTraj&);
};

void Cluster::run(GMXTraj& traj){

    _create_edges(traj);

    // find connected components 
    Graph graph(nodes); 
    for (int i=0; i< edges.size();++i)
        graph.add_edges(edges[i][0],edges[i][1]);
    graph.find_connected_component();
    clusters = std::move(graph.connected_components);
    
    nClusters=clusters.size();

    // find max cluster size 
    max_cluster_size = 1; 
    for (auto clust : clusters)
        if (clust.size() > max_cluster_size)
            max_cluster_size  = clust.size();

    // Upto 5 mer counts 
    /* polymer_counts.clear(); */
    /* for (int i=0; i<=5; ++i) */
    /*     polymer_counts.push_back(0); */

    /* for (auto clust : clusters) */
    /*     if (clust.size() <= 5) */
    /*         ++polymer_counts[clust.size()]; */ 
   
}

/* Cluster::~Cluster(){ */
/*     /1* clusters.clear(); *1/ */
/*     /1* nodes.clear(); *1/ */
/*     /1* edges.clear(); *1/ */
/* } */

void Cluster::set_rcut(float _rcut){
    rcut = _rcut;
}


void Cluster::_create_edges(GMXTraj& traj){
    nodes.clear();
    edges.clear();

    int i_sIDx, i_natoms, i_eIDx;
    int j_sIDx, j_natoms, j_eIDx;
    
    #pragma omp parallel for shared(nodes,edges) 
    for (int i =0; i< traj.nmolecules; ++i){
        /* #pragma critical */ 
        {
        if (traj.molecule_trackers[i].name != molecule_name){
            continue;
        }
        else {
            i_sIDx = traj.molecule_trackers[i].sIDx;
            i_natoms = traj.molecule_trackers[i].natoms; 
            i_eIDx = i_sIDx + i_natoms; 
            std::cout << "Breaking 0 start\n";
            #pragma atomic
            nodes.push_back(i);
            std::cout << "Breaking 0 end\n";
        }
        }

        for (int j=i+1; j<traj.nmolecules; ++j){
            if (traj.molecule_trackers[j].name != molecule_name){
                continue;
            }
            else {
                j_sIDx = traj.molecule_trackers[j].sIDx;
                j_natoms = traj.molecule_trackers[j].natoms; 
                j_eIDx = j_sIDx + j_natoms; 
            }
            
            bool is_neigh=false; 
            for (int ii=i_sIDx; ii<i_eIDx;++ii){
                for (int jj=j_sIDx; jj<j_eIDx; ++jj){
                    float dx = traj.pos[ii][0] - traj.pos[jj][0];
                    float dy = traj.pos[ii][1] - traj.pos[jj][1];
                    float dz = traj.pos[ii][2] - traj.pos[jj][2];
                    
                    // apply PBC 
                    dx = dx - traj.lx*round(dx/traj.lx);
                    dy = dy - traj.ly*round(dy/traj.ly);
                    dz = dz - traj.lz*round(dz/traj.lz);

                    float dist = dx*dx + dy*dy + dz*dz; 

                    if (dist < rcut*rcut){
                        is_neigh = true; 
                        break; 
                    }
                }
                if (is_neigh) break;
            }
            
            {
            if (is_neigh){
                std::vector<int> neigh{i,j};
                /* edges.emplace_back(std::move(neigh)); */
                std::cout << "Breaking 1 start\n";
                #pragma atomic
                edges.push_back(neigh);
                std::cout << "Breaking 1 end\n";
            }
            }
        }
    }
    

}

void print_help(){
    std::cout << "Cluster analysis\n\n";
    
    std::cout << "    -f  *trajectory file [gro,xtc,trr]\n";
    std::cout << "    -s  topology file [gro] (required, if trajectory is XTC/TRR)\n";
    std::cout << "    --mol-name  *name of molecule\n";
    std::cout << "    --sys-info  information about molecule counts [ascii file]\n";
    std::cout << "    -dt  every dt ps  do analysis\n";
    std::cout << "    -b  begin analysis [ps]\n";
    std::cout << "    -e  end analysis [ps]\n";
    std::cout << "    --max-frames  maxium number of frames\n";
    std::cout << "    -h/--help print this message\n";

    exit(0);

}

int main(int argc, char* argv[]){  

    std::string top_file{""};
    std::string traj_file{""};
    std::string mol_name{""};
    std::string sys_info{""};
    std::string log_file{"result_clust.log"};
    float rcut=0.35;
    float dt =1.0;
    float begin = 0.0;
    float end = std::numeric_limits<float>::max();   
    float max_frames = std::numeric_limits<int>::max();   

    // Parse Command Line Argument 
    int i=1;
    while(i<argc && argv[i][0] == '-') {
        std::string opt{argv[i]} ;
        if(opt == "-f") traj_file=argv[++i] ;
        if(opt == "-s") top_file=argv[++i] ;
        if(opt == "--mol-name") mol_name=argv[++i] ;
        if(opt == "--sys-info") sys_info=argv[++i] ;
        if(opt == "-rcut") rcut = atof(argv[++i]);
        if(opt == "-o") log_file=argv[++i] ;
        if(opt == "--max-frames") max_frames=atoi(argv[++i]) ;
        if(opt == "-h") print_help();
        if(opt == "--help") print_help();

        ++i ;
    }
    
    if (traj_file == "" || mol_name == "")
        print_help();


    GMXTraj traj{traj_file,top_file};
    traj.create_molecule_tracker(sys_info);

    Cluster cluster{mol_name};
    cluster.set_rcut(rcut);
    
    std::ofstream log; 
    log.open(log_file);
    log<< "# time   nClusters\n";
    
    int iFrame=0; 
    while(traj.next()){
        if (iFrame >= max_frames) break;

        if (traj.time >= begin && traj.time <= end && std::fmod(traj.time,dt)<0.0001){
            std::cout << "Time: "<< traj.time << " Frame: " << iFrame<<"\n"; 
            cluster.run(traj);
            log << traj.time << "   " 
                << cluster.nClusters << "   " 
                << cluster.max_cluster_size << "  "
                /* << cluster.polymer_counts[1] << "  " */
                /* << cluster.polymer_counts[2] << "  " */
                /* << cluster.polymer_counts[3] << "  " */
                /* << cluster.polymer_counts[4] << "  " */
                /* << cluster.polymer_counts[5] << "  " */
                <<"\n";
            ++iFrame;
        }
    }
    
    return 0;
}

